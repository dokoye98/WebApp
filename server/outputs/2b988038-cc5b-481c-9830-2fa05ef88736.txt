Ready to receive input:
Token{ key=LITERAL, value='2 }
Token{ key=ADDITION, value='+ }
Token{ key=LITERAL, value='2 }
Starting parse process with tokens:
AdditionNode(+): Integer
  |
  --- Literal("2") : String
  --- Literal("2") : String
Analyzing semantics for AST: AdditionNode
Checking expression: Literal("2") : String
Expression is a LiteralNode
Checking expression: Literal("2") : String
Expression is a LiteralNode
BinaryOperationNode: Literal("2") : String, Literal("2") : String
t0 = 10 (2)
t1 = 10 (2)
t2 = t0 + t1
LOAD R0, "10"
LOAD R1, "10"
ADD R2, R0 , R1
MOV result, R2
CALL print, R2
100
Registers: 
R2 = 100
R7 = 0
R12 = 0
R5 = 0
R_TOTAL = 0
R9 = 0
R13 = 0
R6 = 0
R8 = 0
R1 = 10
R11 = 0
R10 = 0
R4 = 0
R0 = 10
R3 = 0
Variables: 
result = 100
Memory: 

Assembly Code here:

section .data
result dd 0
buffer db 'Result: ', 0
buffer_len equ $ - buffer
num_str db '0000000000', 0
num_len equ 10
section .text
global _start
_start:
    mov eax, 2
    add eax, 2
    mov [result], eax
    mov ecx, num_len
    mov esi, result
    mov eax, [esi]
    mov ebx, 10
convert_loop:
    xor edx, edx
    div ebx
    add dl, '0'
    dec ecx
    mov [num_str + ecx], dl
    test eax, eax
    jnz convert_loop
    mov eax, 4
    mov ebx, 1
    mov edx, num_len
    mov ecx, num_str
    int 0x80
    mov eax, 1
    xor ebx, ebx
    int 0x80

Finished processing input.
